package today.pathos.myapplication.study.agent04.result007

import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import today.pathos.myapplication.study.common.BaseViewModel
import today.pathos.myapplication.study.common.Item
import today.pathos.myapplication.study.common.ScreenUiState

class ProduceStateViewModel : BaseViewModel() {
    
    // Local state for items managed by ViewModel
    private val _localItems = MutableStateFlow<List<Item>>(emptyList())
    val localItems: StateFlow<List<Item>> = _localItems.asStateFlow()
    
    // Loading state managed by ViewModel (not by produceState)
    private val _isLocalLoading = MutableStateFlow(false)
    val isLocalLoading: StateFlow<Boolean> = _isLocalLoading.asStateFlow()
    
    // Error state
    private val _error = MutableStateFlow<String?>(null)
    val error: StateFlow<String?> = _error.asStateFlow()
    
    // Trigger for produceState
    private val _refreshTrigger = MutableStateFlow(0)
    val refreshTrigger: StateFlow<Int> = _refreshTrigger.asStateFlow()
    
    // Configuration for produceState
    private val _loadDelay = MutableStateFlow(2000L)
    val loadDelay: StateFlow<Long> = _loadDelay.asStateFlow()
    
    private val _shouldSimulateError = MutableStateFlow(false)
    val shouldSimulateError: StateFlow<Boolean> = _shouldSimulateError.asStateFlow()
    
    // Statistics
    private val _produceStateExecutions = MutableStateFlow(0)
    val produceStateExecutions: StateFlow<Int> = _produceStateExecutions.asStateFlow()
    
    // NO init{} block - initialization handled by produceState
    
    // Suspend function used by produceState
    suspend fun loadItemsForProduceState(): Pair<ScreenUiState, List<Item>> {
        delay(_loadDelay.value)
        
        if (_shouldSimulateError.value) {
            throw Exception("produceState loading failed")
        }
        
        val items = generateInitialItems()
        return ScreenUiState.Succeed to items
    }
    
    // Suspend function for refreshing data in produceState
    suspend fun refreshItemsForProduceState(trigger: Int): Pair<ScreenUiState, List<Item>> {
        delay(1000L)
        
        if (shouldSimulateError()) {
            throw Exception("produceState refresh failed")
        }
        
        val refreshedItems = listOf(
            Item(
                id = "produce-${System.currentTimeMillis()}-1",
                title = "ProduceState Item #$trigger",
                description = "Item generated by produceState refresh trigger $trigger"
            ),
            Item(
                id = "produce-${System.currentTimeMillis()}-2",
                title = "Reactive Item #$trigger",
                description = "Item created reactively via produceState pattern"
            ),
            Item(
                id = "produce-${System.currentTimeMillis()}-3",
                title = "State Produced Item #$trigger",
                description = "Automatically updated when trigger changed to $trigger"
            )
        )
        
        return ScreenUiState.Succeed to refreshedItems
    }
    
    // Methods to control produceState
    fun triggerProduceStateRefresh() {
        _refreshTrigger.value = _refreshTrigger.value + 1
        _produceStateExecutions.value = _produceStateExecutions.value + 1
    }
    
    fun setLoadDelay(delayMs: Long) {
        _loadDelay.value = delayMs
    }
    
    fun toggleSimulateError() {
        _shouldSimulateError.value = !_shouldSimulateError.value
    }
    
    fun resetStatistics() {
        _produceStateExecutions.value = 0
        _refreshTrigger.value = 0
    }
    
    // Local operations (not affecting produceState)
    fun addLocalItem(item: Item) {
        val currentItems = _localItems.value
        _localItems.value = currentItems + item
    }
    
    fun removeLocalItem(itemId: String) {
        val currentItems = _localItems.value
        _localItems.value = currentItems.filterNot { it.id == itemId }
    }
    
    fun updateLocalItem(item: Item) {
        val currentItems = _localItems.value
        _localItems.value = currentItems.map { if (it.id == item.id) item else it }
    }
    
    fun refreshLocalItems() {
        viewModelScope.launch {
            _isLocalLoading.value = true
            _error.value = null
            
            try {
                delay(800)
                
                if (shouldSimulateError()) {
                    throw Exception("Local refresh failed")
                }
                
                val refreshedItems = listOf(
                    Item(
                        id = "local-${System.currentTimeMillis()}-1",
                        title = "Local ViewModel Item",
                        description = "Item loaded by traditional ViewModel method"
                    ),
                    Item(
                        id = "local-${System.currentTimeMillis()}-2",
                        title = "Non-ProduceState Item",
                        description = "Item managed by ViewModel state, not produceState"
                    )
                )
                
                _localItems.value = refreshedItems
                
            } catch (e: Exception) {
                _error.value = e.message
            } finally {
                _isLocalLoading.value = false
            }
        }
    }
    
    fun clearError() {
        _error.value = null
    }
}